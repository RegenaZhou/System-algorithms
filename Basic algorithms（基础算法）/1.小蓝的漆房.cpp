/*
问题描述
小蓝是一位有名的漆匠，他的朋友小桥有一个漆房，
里面有一条长长的走廊，走廊两旁有许多相邻的房子，
每间房子最初被涂上了一种颜色。

小桥来找小蓝，想让他把整个走廊都涂成同一个颜色。
小蓝告诉小桥，他每天只能涂一段长度为 k 的区间。
对于每个区间，他可以选择将其中的房子重新涂上任何一种颜色，
或者保持原来的颜色不变。

小桥想知道小蓝至少要涂几天，才能让整个走廊变得美丽。

请帮助小桥解决这个问题。

输入格式
第一行包含一个整数 t（1≤100），表示测试用例的数量。

每个测试用例的第一行包含两个整数 n 和 k（1≤k≤n≤10^4 ），
第二行包含 n 个整数a1,a2,⋯,an（1≤ai≤60），分别表示每个房子最初的颜色。

保证所有测试用例中 n 的总和不超过10^4 。

输出格式
对于每个测试用例，输出一个整数，表示小蓝需要涂漆的最少天数。

样例输入
2
5 2
1 1 2 2 1
6 2
1 2 2 3 3 3

样例输出
1
2*/
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e4 + 10;
int a[N];
int b[N];

void solve()
{
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    /*<<左移运算符
    1<<1=2,1<<2=4,1<<3=8
    1<<x=1*(2^x)
    1<<31=2^31=2147483648
    int a=2147483648 => -2147483648
    -2147483648-1=2147483647*/
    int ans = 0x3f3f3f3f;//INT_MAX=int的上界(1<<31)-1=2147483647
    for (int i = 1; i <= 60; i++)
    {
        int cnt = 0;
        for (int j = 1; j <= n; j++)
        {
            b[j] = a[j];
        }
        for (int j = 1; j <= n; j++)
        {
            if (b[j] != i)//j~(j+k-1)
            {
                for (int h = j; h <= j + k - 1; h++)
                {
                    b[h] = i;
                }
                cnt++;
                j = j + k - 1;//for中有j++
            }
        }
        ans = min(ans, cnt);
    }
    cout << ans << '\n';
}

int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int t;
    cin >> t;
    while (t--)
    {
        solve();
    }
    return 0;
}