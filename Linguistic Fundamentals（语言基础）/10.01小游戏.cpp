/*
问题描述
小明得到了一个长度为n的字符串s，该字符串都是由数字0和1组成，
并且下标从1开始，小明现在需要对这个字符串进行q次操作，
每次操作包含以下两种操作之一：

操作
1：小明查询该字符串中第一次出现1的位置，并将其输出，
如果字符串中不存在1则输出−1。

操作2：小明选择一个下标，将字符串s中对应该下标的值反转，
即1变为0，0变为1。

小明想在短时间内快速计算出每次操作二的值，你能帮帮他吗。

输入格式
第一行，包含两个正整数n,q(1≤n,q≤2×10^5)，
分别代表字符串长度和操作次数。

第二行，一个字符串s(1≤∣s∣≤n) ，代表输入的字符串。

接下来q行，每行输入格式为一下之一：

1 ，代表小明要查询该字符串中第一次出现1的位置，并将其输出。
2 x ，代表将字符串中下标为x的字符反转。

输出格式
对于每个操作1 ，小明都会输出一行，包含一个正整数，
代表该字符串中第一次出现1的位置，如果字符串中不存在1则输出−1 。

输入样例
6 5
010011
1
2 2
1
2 6
1

输出样例
2
5
5

样例说明
样例中：

小明的第一次操作是查询，我们可以得到字符串 “010011” 
中第一次出现 ‘1’ 的位置为 2 。

小明的第二次操作将下标为2 的字符反转，此时字符串变为 “000011” 。

小明的第三次操作是查询，我们可以得到字符串 “000011” 
中第一次出现 ‘1’ 的位置为5 。

小明的第四次操作是将下标为 6 的字符反转，此时字符串变为 “000010” 。

小明的第五次操作是查询，我们可以得到字符串 “000010” 
中第一次出现 ‘1’ 的位置为5 。*/
#include <iostream>
#include <string>
using namespace std;
int main()
{
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n, q, i, a, b, c;
    string s;
    cin >> n >> q;
    cin >> s;
    for (i = 1; i <= q; ++i)
    {
        cin >> a;
        if (a == 1)
        {
            for (c = 0; c < (int)s.size(); c++)
            {
                if (s[c] == '1')
                {
                    cout << c + 1 << '\n';
                    break;
                }
            }
            if (c >= s.size()) cout << -1 << '\n';
        }
        else if (a == 2)
        {
            cin >> b;
            if (s[b - 1] == '1') s[b - 1] = '0';
            else s[b - 1] = '1';
        }
    }
    return 0;
}